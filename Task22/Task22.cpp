// Задача 3.
// В одномерном массиве, состоящем из N вещественных чисел вычислить:
// - сумму отрицательных элементов;
// - произведение элементов, находящихся между min и max элементами;
// - произведение элементов с четными номерами;
// - сумму элементов, находящихся между первым и последним 
// отрицательными элементами.

#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Russian");
	float ar[7] = { -3.5, 1.5, 2.5, 3.5, 4.5, 5.5, -1.5 };
	cout << "Массив вещественных чисел: " << endl;
	// Задаем массив, состоящий из вещественных чисел
	// Вещественные числа — это числа, у которых есть дробная часть,
	// поэтому задаем тип float

	float sumMinus = 0;
	// Задаем переменную для подсчета суммы отрицательных элементов

	for (int i = 0; i < 7; i++)
		// Задаем цикл для подсчета отрицательных элементов массива
	{
		cout << "ar[" << i << "] = " << ar[i] << endl;
		// Выводим массив на экран
		if (ar[i] < 0)
			sumMinus += ar[i];
		// Если элемент  меньше нуля, то все такие элементы мы суммируем
	}
	cout << "Сумма отрицательных элементов массива = " << sumMinus << endl;
	// Выводим на экран результат суммирования отрицательных элементов

	float mulEvNum = 1;
	// Вводим и инициализируем переменную 
	// для произведения чисел с четными номерами
	for (int i = 1; i < 7; i += 2)
	// Задаем цикл, начиная от 1 (т.к. здесь ar[1] - это второй элемент,
	// устанавливаем шаг 2 (чтобы элеметы считались через один)
	{
		mulEvNum *= ar[i];
	}
	cout << "Произведение элементов с четными номерами = " << mulEvNum << endl;
	// Выводим на экран произведение элементов с четными номерами

	int minInd = 0; int maxInd = 0; 
	// Задаем переменные индекса массива:
	// минимального и максимального
	for (int i = 0; i < 7; i++)
	{
		if (ar[i] < 0)
		{
			minInd = i;
			break;
		}
	}
	for (int i = 6; i > minInd; i--) 
	// Здесь мы приравниваем i к 6, т.к. индексы считаются от нуля
	{
		if (ar[i] < 0)
		{
			maxInd = i;
			break;
		}
	}
	// Задаем циклы для вычисления первого и последнего отрицательных элементов:
	// при выполнении условий цикл прерывается
	minInd++;
	// Используем инкремент для min индекса
	float sumBetMin = 0;
	// Вводим переменную суммы между первым и последним отриц. числами
	for (int i = minInd; i < maxInd; i++)
	// Задаем цикл для перебора значений
	{
		sumBetMin += ar[i];
	}
	cout << "Сумма элементов между первым и последним отрицательными элементами = " << sumBetMin << endl;
	// Выводим на экран результат

	float maxVal = ar[0], minVal = ar[0];
	int maxInd2 = 0, minInd2 = 0;
	// Вводим переменные максимального и минимального значений массива
	for (int i = 1; i < 7; i++)
	// Задаем цикл для определения максимального и минимального значений массива
	{
		if (ar[i] > maxVal)
		{
			maxVal = ar[i];
			maxInd2 = i;
		}
		if (ar[i] < minVal)
		{
			minVal = ar[i];
			minInd2 = i;
		}
	}
	cout << "Минимальный элемент массива: " << minVal << ", в строке: " << minInd2 + 1 << endl;
	cout << "Максимальный элемент массива: " << maxVal << ", в строке: " << maxInd2 + 1 << endl;
	// Выводим на экран минимальное и максимальное значения массива

	float multBetMinMax = 1;
	// Вводим и инициализируем переменную 
	// произведения элементов между min и max
	minInd2++;
	// Используем инкремент для min индекса
	for (int i = minInd2; i < maxInd2; i++)
	// Задаем цикл для определения элементов между min и max,
	// и вычисления их произведения
	{
		multBetMinMax *= ar[i];
	}
	cout << "Произведение элементов между min и max = " << multBetMinMax << endl;
	// Выводим результат на экран

	return 0;
}
