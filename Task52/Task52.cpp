// Задача 2.
// Создайте класс Complex (комплексное число) или используйте уже созданный вами класс.
// Создайте перегруженные операторы для реализации арифметических операций 
// по работе с комплексными числами (операции + , -, *, / ).

// В уже существующий класс Комплексное число добавили перегрузку оператора () 
// + по сравнению с предыдущей версией добавлена перегрузка оператора ввода

#include <iostream>
#include <windows.h>

using namespace std;

class Complex
{
public:
    // Конструктор класса с параметрами по умолчанию
    // Переменные для действительной и мнимной частей задаем в double, 
    // чтобы корректно отображся результат вычисления (как минимум при делении)
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}

    // Перегруженные операторы сложения, вычитания, умножения и деления

    // Сумма двух комплексных чисел вычисляется по формуле:
    // z = (a1 + a2) + (b1 + b2)i
    Complex operator+(const Complex& c) const
    {
        return Complex(real + c.real, imag + c.imag);
    }

    // Разность двух комплексных чисел вычисляется по формуле:
    // z = (a1 - a2) + (b1 - b2)i
    Complex operator-(const Complex& c) const
    {
        return Complex(real - c.real, imag - c.imag);
    }

    // Произведение двух комплексных чисел вычисляется по формуле:
    // z = z1 * z2 = (a1a2 - b1b2) + (a1b2 + b1a2)i
    Complex operator*(const Complex& c) const
    {
        double r = real * c.real - imag * c.imag;
        double i = real * c.imag + imag * c.real;
        return Complex(r, i);
    }

    // Частное двух комплексных чисел вычисляется по формуле:
    // z = z1 / z2 = ((a1a2 + b1b2) / (a2*a2 + b2*b2)) + ((a2b1 -a1b2) / (a2*a2 + b2*b2))i
    Complex operator/(const Complex& c) const
    {
        double r = (real * c.real + imag * c.imag) / (c.real * c.real + c.imag * c.imag);
        double i = (imag * c.real - real * c.imag) / (c.real * c.real + c.imag * c.imag);
        return Complex(r, i);
    }

    // Сеттеры и геттеры для значений вещественной и мнимой частей
    void setReal(double r) { real = r; }
    void setImag(double i) { imag = i; }
    double getReal() const { return real; }
    double getImag() const { return imag; }

    // Оператор () позволяет установить новое значение объекта класса Complex, 
    // передавая два аргумента - новые значения для real и imag комплексного числа
    Complex operator()(double r, double i) // перегрузка оператора вызова функции
    {
        real = r;
        imag = i;
        return *this; // возвращаем измененный объект класса Complex
    }

    // Перегруженный оператор вывода (обращаемся к дружественной функции)
    friend ostream& operator<<(ostream& out, const Complex& c);
    // Перегруженный оператор ввода (обращаемся к дружественной функции)
    friend istream& operator>>(istream& in, Complex& c);

private:
    double real, imag; // переменные для действительной и мнимой частей
};

// Перегруженный оператор вывода <<
// Перегрузка оператора вывода позволяет нам определить, как именно будут выведены значения 
// Можно обойтись без перегрузки, но тогда придется вызывать геттеры для вывода вещественной 
// и мнимой частей отдельно (добавляем сразу + и i после значения мнимой части)
// Перегрузка оператора вывода улучшит читаемость кода
ostream& operator<<(ostream& out, const Complex& c)
{
    out << c.real << " + " << c.imag << "i";
    return out;
}

// Перегруженный оператор ввода >>
// Избавляет нас от четырех изначально введенных переменных (real1, imag1, real2, imag2)
istream& operator>>(istream& in, Complex& c)
{
    cout << "Введите действительную часть комплексного числа: ";
    in >> c.real;
    cout << "Введите мнимую часть комплексного числа: ";
    in >> c.imag;
    cout << endl;
    return in;
}

int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    cout << "\t\t\t = Добро пожаловать в программу для арифметических действий с комплексными числами! = " << endl << endl;
    cout << "\t\t\t\t::: Введите действительную и мнимую части двух комплексных чисел ::: " << endl << endl;

    // с1 и с2 оставил из предыдущей версии (без перегрузки оператора ()), 
    // чтобы наглядно увидеть отличия (но с перегрузкой ввода)
    Complex c1, c2;
    cin >> c1 >> c2;
    cout << "Комплексное число №1: " << c1 << endl;
    cout << "Комплексное число №2: " << c2 << endl;
    Complex add = c1 + c2;
    cout << endl << "Сумма (+) двух комплексных чисел: " << add << endl;
    Complex subtr = c1 - c2;
    cout << "Разность (-) двух комплексных чисел: " << subtr << endl;
    Complex multipl = c1 * c2;
    cout << "Произведение (*) двух комплексных чисел: " << multipl << endl;
    Complex divis = c1 / c2;
    cout << "Частное (/) двух комплексных чисел: " << divis << endl << endl;

    // После добавления перегрузки оператора(), объекты c3 и c4 могут быть вызваны как функции 
    // в которые передается два аргумента типа double
    Complex c3, c4;

    // Вместо Complex c3 можно использовать просто c3, 
    // т.к. c3 уже определен как объект класса Complex и перегрузка оператора () 
    // позволяет устанавливать его значения без явного использования имени класса
    c3(0.12, 4.9);
    c4(-0.001, -2);
    cout << "Комплексное число №3 после вызова оператора(): " << c3 << endl;
    cout << "Комплексное число №4 после вызова оператора(): " << c4 << endl;

    add = c3 + c4; // не используем имя класса
    cout << endl << "Сумма (+) двух комплексных чисел: " << add << endl;
    subtr = c3 - c4;
    cout << "Разность (-) двух комплексных чисел: " << subtr << endl;
    multipl = c3 * c4;
    cout << "Произведение (*) двух комплексных чисел: " << multipl << endl;
    divis = c3 / c4;
    cout << "Частное (/) двух комплексных чисел: " << divis << endl << endl;

    system("pause");
    return 0;
}