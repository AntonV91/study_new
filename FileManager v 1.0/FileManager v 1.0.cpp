// Реализовать простейший файловый менеджер с использованием ООП (классы, наследование и так далее).
// Файловый менеджер должен иметь такие возможности:
// - показывать содержимое дисков;
// - создавать папки / файлы;
// - удалять папки / файлы;
// - переименовывать папки / файлы;
// - копировать / переносить папки / файлы;
// - вычислять размер папки / файла;
// - производить поиск по маске(с поиском по подпапкам) и так далее.

#include <iostream>
#include <vector>
#include <string>
#include <windows.h>

using namespace std;

// Пока сдаю предполагаемый "скелет", т.к. не было времени продумать концепцию глубже
// (не вижу пока картину целиком и не уверен, что правильно понимаю то, что от меня требуется)
// ДОПОЛНЕНИЕ ОТНОСИТЕЛЬНО ВЕРСИИ ОТ 02.05 НАХОДИТСЯ НИЖЕ (ПОСЛЕ //==== ... 
// ТАМ ПОПЫТКА РАЗОБРАТЬСЯ С FILESYSTEM)

// Класс, представляющий файловый менеджер
class FileManager
{
private:
    string currentDir;  // Текущая директория

public:
    FileManager()
    {
        currentDir = "/";
    }

    // Метод для отображения содержимого диска
    void showDiskContent()
    {
        cout << "Содержимое диска:\n\n";
        // Здесь будет код для реализации следующих функций: 
        // - получения содержимого диска;
        // - отображение содержимого диска.
        // При изучении материалов наткнулся на такие функции, 
        // как closedir, opendir, readdir, rewinddir и т.п.
        // Здесь, теоретически, можно использовать opendir() для получения списка файлов и папок,
        // затем перебрать список и вывести названия файлов и папок на экран
        // ПОДСКАЖИТЕ, ПОЖАЛУЙСТА, СТОИТ ЛИ ТАК СДЕЛАТЬ ИЛИ СТОИТ ИСПОЛЬЗОВАТЬ ДРУГИЕ ИНСТРУМЕНТЫ
        // (я пока не разобрался как именно)
    }

    // Метод для создания папки
    void createDir(const string& dirName)
    {
        cout << "Создаем директорию: " << dirName << "\n";
        // Здесь, как я понял, можно использовать функцию из той же оперы: mkdir()
    }

    // Метод для создания файла
    void createFile(const string& fileName)
    {
        cout << "Создаем файл: " << fileName << "\n";
        // Здесь будет реализация кода для создания файла с указанным именем
        // (возможно через fopen())
    }

    // Метод для удаления папки
    void deleteDir(const string& dirName)
    {
        cout << "Удаляем директорию: " << dirName << "\n";
        // Здесь впоследствии реализуем код для удаления папки с указанным именем
        // Например, можно использовать функцию rmdir()
    }

    // Метод для удаления файла
    void deleteFile(const string& fileName)
    {
        cout << "Удаляем файл: " << fileName << "\n";
        // Пойдем, скорее всего, через использование remove()
    }

    // Метод для переименования папки или файла
    void rename(const string& oldName, const string& newName)
    {
        cout << "Переименовываем " << oldName << " в " << newName << "\n";
        // Например, можно использовать функцию rename()
        // Функция rename переименовывает файл или каталог, указанный параметром oldname,
        // на имя, заданное параметром newname
    }

    // Метод для копирования папки или файла
    void copy(const string& source, const string& destination)
    {
        cout << "Копируем " << source << " в " << destination << "\n";
        // Здесь будет код для копирования папки или файла из текущей папки в указанную
        // Можно использовать функцию copy()
    }

    // Метод для перемещения папки или файла
    void move(const string& source, const string& destination)
    {
        cout << "Перемещаем " << source << " в " << destination << "\n";
        // Здесь будет реализация кода для перемещения папки или файла из текущей папки в указанную
        // Возможно, стоит сделать так: MoveFile (path1, path2), где path1 - текущая папка,
        // а path2 - папка назначения. Или как-то через rename() с указанием обоих путей
    }

    // Метод для вычисления размера папки или файла
    void calculateSize(const string& name)
    {
        cout << "Вычисляем размер " << name << "\n";
        // Здесь, вероятно, получится использовать stat() или lstat() для получения 
        // информации о файле или папке. Может как-то поиграться с sizeof
    }

    // Метод для выполнения поиска по маске
    void searchByMask(const string& mask)
    {
        cout << "Ищем по маске: " << mask << "\n";
        // Здесь будет реализация кода для поиска по указанной маске в папке/подпапках
        // Наверное, можно снова использовать opendir() для получения списка файлов и папок,
        // а затем проверять каждый элемент списка на соответствие маске
    }
};

int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    // Вызываем наши методы в "тестовом режиме"
    FileManager fileManager;
    fileManager.showDiskContent();
    fileManager.createDir("Новая папка");
    fileManager.createFile("Новый файл.txt");
    fileManager.deleteDir("Папка для удаления");
    fileManager.deleteFile("Файл для удаления.txt");
    fileManager.rename("Старое название.txt", "Новое название.txt");
    fileManager.copy("Исходный файл.txt", "Папка назначения");
    fileManager.move("Исходный файл.txt", "Папка назначения");
    fileManager.calculateSize("Папка для которой вычисляем размер");
    fileManager.searchByMask("*.txt");
    return 0;

    // Буду признателен, если дадите комментарии/советы по работе 
    // (например, стоит ли использовать методы для работы с директориями/файлами, 
    // которые я описал в заготовках методов или лучше использвать другие)
    // Заранее благодарю!
}

// ==========================================================================================

// За прошедшее со сдачи версии 1.0 время увидел, что существует пространство имен filesystem
// (в стандарте С++ от 17 и выше), которое предоставляет средства для выполнения операций 
// с файловыми системами и их компонентами, такими как пути, обычные файлы и каталоги.

// Для его использования подключаем:
#include <filesystem>
namespace fs = std::filesystem;

// Если верить информации в интернете, filesystem является самым удобным и эффективным способом
// для работы с директориями. Попробовал начать работу с ним, опираясь на шаблоны из интернета. 
// Вот схематичное начало, дальше я потерялся. Жизненно необходимы ваши комментарии 
// (НА ЧЕМ ОСТАНОВИТЬСЯ ПРИ НАПИСАНИИ ПРОГРАММЫ, ЧТО ДЕЛАТЬ ДАЛЬШЕ и т.п.) 
// Если честно, сильно застопорился. ПОМОГИТЕ, ПОЖАЛУЙСТА!

 /*class FileManager
{
private:
    fs::path currentDir;  // Текущая директория

public:
    FileManager()
    {
        currentDir = fs::current_path();
    }

    void showDiskContent() // Показываем содержимое диска
    {
        // перебор файлов в каталоге при помощи итератора
        for (auto& p : fs::directory_iterator(currentDir))
        {
            std::cout << p.path().string() << "\n";
        }
    }

    void createDir(const std::string& dirName) // Создаем директорию
    {
        fs::create_directory(currentDir / dirName);
    }

    // ... Здесь будут остальные методы класса ...

    int main()
    {
        return 0;
    }
    */